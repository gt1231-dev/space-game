<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Step D - Coins & Shop (Recovery)</title>
  <style>
    body{margin:0;background:#111;height:100vh;display:flex;justify-content:center;align-items:center}
    canvas{background:#0b1220;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.55);touch-action:none}
  </style>
</head>
<body>
<canvas id="c" width="420" height="740"></canvas>

<script>
const c = document.getElementById("c");
const g = c.getContext("2d");

// 논리 좌표계(게임은 이 크기로 그림)
const W = 420, H = 740;

// ✅ Retina/DPR 보정: 내부 픽셀만 키우고, 그리는 좌표계는 그대로 유지
const DPR = window.devicePixelRatio || 1;
c.style.width = W + "px";
c.style.height = H + "px";
c.width = Math.round(W * DPR);
c.height = Math.round(H * DPR);
g.setTransform(DPR, 0, 0, DPR, 0, 0);
g.imageSmoothingEnabled = true;

// =====================================================
// ✅ SFX (WebAudio) - Safari/iOS 확실 언락 + 단일 구현
// =====================================================
let audioCtx = null;
let master = null;
let sfxOn = true;
let audioUnlocked = false;

function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint:"interactive" });
  master = audioCtx.createGain();
  master.gain.value = 0.9;
  master.connect(audioCtx.destination);
}

function unlockAudioNow(){
  if(!sfxOn) return;
  try{
    initAudio();

    // ✅ 조건 없이 무조건 resume 시도 (iOS/Safari에서 더 안정적)
    try{ audioCtx.resume(); }catch(e){}

    // ✅ iOS/Safari unlock 핵심: 무음 버퍼 1번 재생
    const buf = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(master);
    src.start(0);

    audioUnlocked = true;
  }catch(e){}
}


function ensureAudio(){
  if(!sfxOn) return null;
  initAudio();
  // running 아니어도 여기서 바로 resume 시도
  if(audioCtx.state !== "running") {
    try{ audioCtx.resume(); }catch(e){}
  }
  return audioCtx;
}


function beep(freq=440, dur=0.08, type="sine", vol=0.10){
  const ctx = ensureAudio(); if(!ctx) return;
  const t0 = ctx.currentTime;

  const o = ctx.createOscillator();
  const gg = ctx.createGain();

  o.type = type;
  o.frequency.setValueAtTime(freq, t0);

  gg.gain.setValueAtTime(0.0001, t0);
  gg.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
  gg.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

  o.connect(gg);
  gg.connect(master);

  o.start(t0);
  o.stop(t0 + dur + 0.02);
}

function sweep(f1=800, f2=200, dur=0.18, type="sawtooth", vol=0.10){
  const ctx = ensureAudio(); if(!ctx) return;
  const t0 = ctx.currentTime;

  const o = ctx.createOscillator();
  const gg = ctx.createGain();

  o.type = type;
  o.frequency.setValueAtTime(f1, t0);
  o.frequency.exponentialRampToValueAtTime(Math.max(30, f2), t0 + dur);

  gg.gain.setValueAtTime(0.0001, t0);
  gg.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
  gg.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

  o.connect(gg);
  gg.connect(master);

  o.start(t0);
  o.stop(t0 + dur + 0.02);
}

function noiseHit(dur=0.10, vol=0.08){
  const ctx = ensureAudio(); if(!ctx) return;
  const t0 = ctx.currentTime;

  const bufferSize = Math.floor(ctx.sampleRate * dur);
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++){
    data[i] = (Math.random()*2-1) * (1 - i/bufferSize);
  }

  const src = ctx.createBufferSource();
  src.buffer = buffer;

  const gg = ctx.createGain();
  gg.gain.setValueAtTime(vol, t0);
  gg.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

  src.connect(gg);
  gg.connect(master);

  src.start(t0);
  src.stop(t0 + dur + 0.02);
}

const SFX = {
  shoot(){ beep(900, 0.05, "square", 0.10); },
  coin(){  beep(1200,0.06,"sine",0.12); beep(1600,0.05,"sine",0.10); },
  buy(){   beep(700,0.07,"triangle",0.12); beep(980,0.08,"triangle",0.10); },
  hit(){   noiseHit(0.10, 0.10); },
  gameover(){ sweep(420, 120, 0.28, "sawtooth", 0.14); },
  shopOpen(){  beep(520,0.06,"triangle",0.10); },
  shopClose(){ beep(380,0.06,"triangle",0.10); },
};

// 사용자 입력 시 오디오 잠금 해제(모바일 필수)
addEventListener("pointerdown", unlockAudioNow, {passive:true});
addEventListener("touchstart", unlockAudioNow, {passive:true});
addEventListener("mousedown", unlockAudioNow, {passive:true});
addEventListener("keydown", unlockAudioNow, {passive:true});

// ===== utils =====
const LANES=3, laneX=i=>W*(i+.5)/LANES, clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const pick=a=>a[(Math.random()*a.length)|0];
const aabb=(ax,ay,aw,ah,bx,by,bw,bh)=>ax<bx+bw&&ax+aw>bx&&ay<by+bh&&ay+ah>by;

function formatShort(n){
  const sign = n < 0 ? "-" : "";
  n = Math.abs(n);
  if (n < 1000) return sign + String(Math.floor(n));
  let tier = 0;
  let val = n;
  while (val >= 1000) { val /= 1000; tier++; }
  function tierToLetters(t){
    let s = "";
    while (t > 0) { t--; s = String.fromCharCode(97 + (t % 26)) + s; t = Math.floor(t / 26); }
    return s;
  }
  const suffix = tierToLetters(tier);
  let txt;
  if (val >= 100) txt = String(Math.floor(val));
  else txt = (Math.round(val * 10) / 10).toFixed(1).replace(/\.0$/, "");
  return sign + txt + suffix;
}

// ===== save =====
const UP_KEY = "lw_like_up_v1";
const up={ startTroops:10, dmg:6, rate:6 };
try{
  const raw=localStorage.getItem(UP_KEY);
  if(raw){
    const o=JSON.parse(raw);
    if(typeof o.startTroops==="number") up.startTroops=o.startTroops;
    if(typeof o.dmg==="number") up.dmg=o.dmg;
    if(typeof o.rate==="number") up.rate=o.rate;
  }
}catch{}
function saveAll(){ try{ localStorage.setItem(UP_KEY, JSON.stringify(up)); }catch{} }

// ===== game state =====
let mode="start"; // start | play | gameover | shop
let lane=1, target=1, troops=up.startTroops;
let speed=240, t=0, coins=0;
let timeS = 0;

// HP / lives
let hp=60, maxHp=60;
let lives = 0;

// shop buffs
let healMul = 1;
let dmgMul = 1;

// stage
let stage = 0;
let stageClock = 0;
let stageFlash = 0;  // ✅ 스테이지 알림 배너 타이머

// toast
let toastMsg = "";
let toastT = 0;
function toast(msg, sec=1.2){ toastMsg = msg; toastT = sec; }

// bullets
const bullets=[]; let fireCd=0;
let fireAnim = 0;

// player/objects
const player={y:H-140,w:56,h:92};
const objs=[]; // gate/enemy/coin/potion

// ===== Mobile Arrow Buttons =====
const BTN = {
  size: 64,
  gap: 14,
  y: H - 194,
  left:  { x: 24, w: 64, h: 64, y: 0 },
  right: { x: W - 24 - 64, w: 64, h: 64, y: 0 },
};
function inRect(x, y, r){ return x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h; }

// ===== START 버튼 영역(정확 좌표) =====
const START_BTN = { x: 70, y: 420, w: W-140, h: 74 };
function inStartBtn(x,y){
  return x>=START_BTN.x && x<=START_BTN.x+START_BTN.w && y>=START_BTN.y && y<=START_BTN.y+START_BTN.h;
}

// ===== potion system =====
let potionSpawnedThisStage = false; // ✅ 한 스테이지에 한 개만
function spawnPotion(){
  const ratio = Math.random() < 0.5 ? 0.5 : 1.0;
  objs.push({
    type:"potion",
    lane:(Math.random()*3)|0,
    y:-240,
    w:46,h:46,
    ratio,
    hit:false
  });
  potionSpawnedThisStage = true;
}
function collectPotion(o){
  const heal = Math.round(maxHp * o.ratio);
  hp = Math.min(maxHp, hp + heal);
  beep(520, 0.07, "triangle", 0.07);
  toast(o.ratio === 1 ? "물약: HP 100% 회복!" : "물약: HP 50% 회복!", 2.0);
}

// ===== reset =====
function resetRun(){
  mode="start";
  coins=0;
  troops=up.startTroops;

  lives = 0;
  healMul = 1;
  dmgMul = 1;

  lane=1; target=1;
  speed=240; t=0;
  timeS=0;

  objs.length=0;
  bullets.length=0;
  fireCd=0;

  hp=maxHp;
  stage=0;
  stageClock=0;
  stageFlash=0;

  potionSpawnedThisStage = false;
}

// ✅ START 눌렀을 때만 플레이 시작 + 오디오 테스트 비프
function startGame(){
  unlockAudioNow();
  beep(880, 0.06, "sine", 0.12);   // ✅ START 누르면 “삐” 들리면 성공

  mode="play";
  tryShoot();
}

// ===== spawn =====
function spawnRow(){
  const l1=(Math.random()*3)|0, l2=(l1+1+((Math.random()*2)|0))%3;

  const kind=()=>{ const r=Math.random(); return r<.55?"add":r<.8?"mul":r<.92?"sub":"div"; };
  const val=(k)=>k==="add"?pick([5,10,15,20,25,30]):k==="mul"?pick([2,3,4]):k==="sub"?pick([5,10,15]):pick([2,3]);
  const makeGate=(ln)=>{ const k=kind(); return {type:"gate",lane:ln,y:-120,w:134,h:90,k,val:val(k),hit:false}; };
  objs.push(makeGate(l1), makeGate(l2));

  // coin
  objs.push({type:"coin",lane:(Math.random()*3)|0,y:-200,w:44,h:44,amt:pick([5,10,15,20]),hit:false});

  // potion: 한 스테이지에 한 개만
  if(!potionSpawnedThisStage){
    const chance = clamp(0.22 + stage*0.01, 0.22, 0.34);
    if(Math.random() < chance) spawnPotion();
  }

  // enemies 1~2
  const twoChance = clamp(0.25 + stage*0.03, 0.25, 0.75);
  const n = Math.random() < twoChance ? 2 : 1;

  for(let i=0;i<n;i++){
    const dps = currentDps();
    const ttk = clamp(0.85 + stage * 0.03, 0.85, 1.6);
    const variance = 0.90 + Math.random() * 0.25;

    let baseHp = Math.round(dps * ttk * variance);
    const minHp = 10 + stage * 2;
    const enemyMaxHp = Math.round(dps * 1.6);
    baseHp = clamp(baseHp, minHp, enemyMaxHp);

    const lvl = Math.max(1, Math.round(baseHp / 6));

    objs.push({
      type:"enemy",
      lane:(Math.random()*3)|0,
      y:-300-i*90,
      w:72,h:72,
      hp: baseHp,
      maxHp: baseHp,
      lvl: lvl,
      hit:false
    });
  }
}

function endGame(){
  if(lives > 0){
    lives--;
    hp=maxHp;
    return;
  }
  mode="gameover";
  SFX.gameover();
  saveAll();
}

function applyGate(o){
  if(o.k==="add") troops+=o.val;
  else if(o.k==="mul") troops*=o.val;
  else if(o.k==="sub") troops-=o.val;
  else troops=Math.floor(troops/o.val);
  troops=Math.max(0,Math.floor(troops));
  if(troops<=0){ troops=0; endGame(); }
}

function collectCoin(o){
  coins += o.amt;
  troops += Math.ceil(o.amt * 0.5);
  SFX.coin();
}

function takeDamage(amount){
  hp -= amount;
  SFX.hit();
  if(hp <= 0){
    hp = 0;
    endGame();
  }
}

function hitEnemyBody(o){
  const base = Math.ceil(o.maxHp * 0.22);
  const scale = Math.floor(Math.sqrt(Math.max(0, troops)) / 25);
  const dmgToPlayer = clamp(base + scale, 4, 30);
  o.hp -= Math.ceil((up.dmg + 2) * 0.8);
  takeDamage(dmgToPlayer);
}

function hitEnemyBullet(o,dmg){
  o.hp -= dmg;
  if(o.hp <= 0){
    troops += Math.max(1, Math.floor(o.maxHp * 0.14));
  }
}

function calcScorePower(){
  return clamp(Math.floor(Math.sqrt(Math.max(0, troops)) / 16), 0, 26);
}
function currentShotDmg(){
  return Math.floor((up.dmg + calcScorePower()) * dmgMul);
}
function currentRate(){
  return Math.max(2.5, up.rate * 0.85);
}
function currentDps(){
  return Math.max(1, currentShotDmg() * currentRate());
}

function tryShoot(){
  if(mode!=="play") return;
  if(fireCd>0) return;

  const ln=Math.round(target);

  fireAnim = 0.10;
  SFX.shoot();
  bullets.push({
    lane: ln,
    y: player.y - player.h/2 - 14,
    r: 5,
    v: 620,
    dmg: currentShotDmg(),
    t: 0
  });

  const effectiveRate = Math.max(2.5, up.rate * 0.85);
  fireCd = 1 / effectiveRate;
}

// ===== input =====
addEventListener("keydown",(e)=>{
  const k=e.key.toLowerCase();

  // start 화면: Space/Enter로 시작
  if(mode==="start"){
    if(e.code==="Space" || e.code==="Enter"){
      startGame();
      e.preventDefault();
      return;
    }
  }

  if(mode==="play"){
    if(k==="a"||e.key==="ArrowLeft") target=clamp(target-1,0,2);
    if(k==="d"||e.key==="ArrowRight") target=clamp(target+1,0,2);
  }

  if(k==="b"){
    if(mode==="play"){ mode="shop"; SFX.shopOpen(); }
    else if(mode==="shop"){ mode="play"; SFX.shopClose(); }
  }

  if(e.code==="Space"){
    if(mode==="play") tryShoot();
    else if(mode==="gameover") resetRun();
    e.preventDefault();
  }
});

// click: start=button, play=shoot, gameover=restart
c.addEventListener("click", (ev)=>{
  const r = c.getBoundingClientRect();
  const x = (ev.clientX - r.left) * (W / r.width);
  const y = (ev.clientY - r.top)  * (H / r.height);

  if(mode==="start"){
    if(inStartBtn(x,y)) startGame();
    return;
  }

  if(mode==="play") tryShoot();
  else if(mode==="gameover") resetRun();
});

// mobile touch control
c.addEventListener("touchstart", onTouch, {passive:false});
c.addEventListener("touchmove", onTouchMove, {passive:false});

function onTouch(e){
  const r = c.getBoundingClientRect();
  const t0 = e.touches[0];
  const x = (t0.clientX - r.left) * (W / r.width);
  const y = (t0.clientY - r.top)  * (H / r.height);

  // START 화면: 버튼 터치로만 시작
  if(mode==="start"){
    if(inStartBtn(x,y)) startGame();
    e.preventDefault();
    return;
  }

  // PLAY
  if(mode === "play"){
    // 상점 버튼 터치
    const bw = 92, bh = 34;
    const bx = W - bw - 12;
    const by = 56;

    if(x >= bx && x <= bx + bw && y >= by && y <= by + bh){
      mode = "shop";
      SFX.shopOpen();
      e.preventDefault();
      return;
    }

    // 좌/우 버튼 터치
    BTN.left.y = BTN.y; BTN.right.y = BTN.y;

    if(inRect(x, y, BTN.left)){
      target = clamp(target - 1, 0, 2);
      e.preventDefault();
      return;
    }
    if(inRect(x, y, BTN.right)){
      target = clamp(target + 1, 0, 2);
      e.preventDefault();
      return;
    }

    // 화면 중앙 기준 이동 + 발사
    if(x >= W/2) target = clamp(target + 1, 0, 2);
    else        target = clamp(target - 1, 0, 2);

    tryShoot();
    e.preventDefault();
    return;
  }

  // SHOP
  if(mode === "shop"){
    if(x>=40 && x<=W-40 && y>=90 && y<=130){
      mode="play";
      SFX.shopClose();
      e.preventDefault();
      return;
    }

    const items = shopItems();
    const x0=40, y0=220, w0=W-80, rowH=62;
    for(let i=0;i<items.length;i++){
      const yy = y0 + i*rowH;
      if(x>=x0 && x<=x0+w0 && y>=yy && y<=yy+rowH-10){
        buy(items[i]);
        e.preventDefault();
        return;
      }
    }
    e.preventDefault();
    return;
  }

  // GAMEOVER
  if(mode === "gameover"){
    resetRun();
    e.preventDefault();
    return;
  }
}
function onTouchMove(e){ e.preventDefault(); }

// shop purchase click (desktop)
c.addEventListener("mousedown",(e)=>{
  if(mode!=="shop") return;
  const r=c.getBoundingClientRect();
  const mx=(e.clientX-r.left)*(W/r.width);
  const my=(e.clientY-r.top)*(H/r.height);

  if(mx>=40 && mx<=W-40 && my>=90 && my<=130){ mode="play"; return; }

  const items=shopItems();
  const x0=40, y0=220, w0=W-80, rowH=62;
  for(let i=0;i<items.length;i++){
    const yy=y0+i*rowH;
    if(mx>=x0 && mx<=x0+w0 && my>=yy && my<=yy+rowH-10){
      buy(items[i]);
      return;
    }
  }
});

function shopItems(){
  return [
    {
      name: `체력 증가량 UP (x${healMul.toFixed(1)})`,
      cost: 120 + Math.floor((healMul - 1) * 260),
      act: () => healMul += 0.25
    },
    {
      name: `공격력 1.5배 (x${dmgMul.toFixed(1)})`,
      cost: 260 + Math.floor(Math.log2(dmgMul) * 220),
      act: () => dmgMul *= 1.5
    },
    {
      name: `목숨 +1 (현재 ${lives})`,
      cost: 420 + lives * 260,
      act: () => lives++
    },
  ];
}

function buy(it){
  const cost = it.cost;
  if(coins < cost) return;
  coins -= cost;
  it.act();
  SFX.buy();
  toast(`구매: ${it.name}`, 3.0);
}

// ===== render helpers =====
function rr(x0,y0,w,h,r){
  r=Math.min(r,w/2,h/2); g.beginPath(); g.moveTo(x0+r,y0);
  g.arcTo(x0+w,y0,x0+w,y0+h,r); g.arcTo(x0+w,y0+h,x0,y0+h,r);
  g.arcTo(x0,y0+h,x0,y0,r); g.arcTo(x0,y0,x0+w,y0,r); g.closePath();
}
function rrCtx(ctx, x0, y0, w, h, r){
  r = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x0 + r, y0);
  ctx.arcTo(x0 + w, y0,     x0 + w, y0 + h, r);
  ctx.arcTo(x0 + w, y0 + h, x0,     y0 + h, r);
  ctx.arcTo(x0,     y0 + h, x0,     y0,     r);
  ctx.arcTo(x0,     y0,     x0 + w, y0,     r);
  ctx.closePath();
}

// ===== enemy render (planet) =====
function drawPlanet(ctx, x, y, o, time){
  const lvl = o.lvl || 1;
  const type = (lvl - 1) % 8;
  const r = clamp(44 + lvl*2.3, 44, 108);

  const float = Math.sin(time*2.0 + type) * 1.4;

  const base = ["#F4A261","#F6D365","#8ED1E8","#F07C6C","#F2C35B","#F1DCA7","#A5E3E6","#5B86C6"][type];
  const pat  = ["rgba(180,120,80,0.45)","rgba(210,150,70,0.35)","rgba(70,190,120,0.40)","rgba(170,70,60,0.45)",
                "rgba(160,110,60,0.35)","rgba(180,150,90,0.30)","rgba(70,140,150,0.35)","rgba(40,80,130,0.35)"][type];

  ctx.save();
  ctx.translate(x, y + float);

  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fillStyle=base; ctx.fill();
  ctx.beginPath(); ctx.arc(-r*0.28, -r*0.30, r*0.35, 0, Math.PI*2);
  ctx.fillStyle="rgba(255,255,255,0.22)"; ctx.fill();

  ctx.save();
  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.clip();

  if(type===0 || type===3){
    ctx.fillStyle=pat;
    const pts=[[-0.35,-0.05,0.18],[0.20,-0.25,0.14],[0.28,0.18,0.16],[-0.10,0.28,0.12]];
    for(const [px,py,pr] of pts){
      ctx.beginPath(); ctx.arc(px*r,py*r,pr*r,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px*r-pr*r*0.2,py*r-pr*r*0.2,pr*r*0.6,0,Math.PI*2);
      ctx.fillStyle="rgba(0,0,0,0.10)"; ctx.fill();
      ctx.fillStyle=pat;
    }
  }
  if(type===1){
    ctx.save(); ctx.rotate(-0.5); ctx.fillStyle=pat;
    for(let i=-2;i<=2;i++){
      ctx.globalAlpha=(i%2===0)?0.28:0.18;
      ctx.fillRect(-r*1.4,i*r*0.34,r*2.8,r*0.14);
    }
    ctx.restore(); ctx.globalAlpha=1;
  }
  if(type===2){
    ctx.globalAlpha=0.9; ctx.fillStyle=pat;
    ctx.beginPath(); ctx.ellipse(-r*0.22,-r*0.05,r*0.55,r*0.28,0.25,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r*0.24,r*0.20,r*0.42,r*0.24,-0.55,0,Math.PI*2); ctx.fill();

    ctx.globalAlpha=0.35; ctx.strokeStyle="rgba(255,255,255,0.65)"; ctx.lineWidth=5;
    ctx.beginPath(); ctx.arc(0,0,r*0.72,0.3,Math.PI-0.3); ctx.stroke();
    ctx.globalAlpha=1;
  }
  if(type===4){
    ctx.save(); ctx.rotate(0.15);
    for(let i=-3;i<=3;i++){
      ctx.fillStyle=(i%2===0)?"rgba(255,255,255,0.18)":pat;
      ctx.fillRect(-r*1.4,i*r*0.28,r*2.8,r*0.16);
    }
    ctx.restore();
  }
  if(type===6 || type===7){
    ctx.strokeStyle="rgba(255,255,255,0.22)"; ctx.lineWidth=6;
    ctx.beginPath(); ctx.arc(0,0,r*0.72,0.25,Math.PI-0.25); ctx.stroke();
    ctx.globalAlpha=0.25; ctx.strokeStyle="rgba(0,0,0,0.18)"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.arc(0,0,r*0.55,0.35,Math.PI-0.35); ctx.stroke();
    ctx.globalAlpha=1;
  }
  ctx.restore();

  if(type===5){
    ctx.save(); ctx.rotate(-0.35);
    ctx.strokeStyle="rgba(255,255,255,0.55)"; ctx.lineWidth=10;
    ctx.beginPath(); ctx.ellipse(0,0,r*1.55,r*0.62,0,0,Math.PI*2); ctx.stroke();
    ctx.strokeStyle="rgba(0,0,0,0.10)"; ctx.lineWidth=6;
    ctx.beginPath(); ctx.ellipse(0,0,r*1.30,r*0.52,0,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  const eyeY=-r*0.12, eyeX=r*0.20;
  ctx.fillStyle="rgba(255,255,255,0.95)";
  ctx.beginPath(); ctx.arc(-eyeX,eyeY,r*0.16,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc( eyeX,eyeY,r*0.16,0,Math.PI*2); ctx.fill();
  const px = Math.sin(time*2.2 + type) * r*0.04;
  const py = Math.cos(time*2.0 + type) * r*0.03;
  ctx.fillStyle="rgba(0,0,0,0.85)";
  ctx.beginPath(); ctx.arc(-eyeX+px,eyeY+py,r*0.06,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc( eyeX+px,eyeY+py,r*0.06,0,Math.PI*2); ctx.fill();

  const hpTxt = formatShort(o.hp);
  const fontSize = Math.round(clamp(18 + lvl*0.15, 18, 28));
  ctx.font = `900 ${fontSize}px system-ui`;
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.lineJoin="round"; ctx.miterLimit=2;
  ctx.lineWidth=7; ctx.strokeStyle="rgba(0,0,0,0.55)";
  ctx.fillStyle="rgba(255,255,255,0.98)";
  const textY = Math.round(r * 0.40);
  ctx.strokeText(hpTxt,0,textY);
  ctx.fillText(hpTxt,0,textY);

  ctx.restore();
}

// ===== potion render =====
function drawPotion(ctx, x, y, o){
  ctx.save();
  ctx.translate(x, y);
  const r = 22;

  ctx.globalAlpha = 0.18;
  ctx.beginPath(); ctx.arc(0,0,r*1.5,0,Math.PI*2); ctx.fillStyle="rgba(120,255,180,1)"; ctx.fill();
  ctx.globalAlpha = 1;

  ctx.fillStyle = "rgba(230,255,240,0.95)";
  rrCtx(ctx, -16, -18, 32, 40, 10); ctx.fill();

  ctx.fillStyle = (o.ratio===1) ? "rgba(80,240,160,0.95)" : "rgba(120,255,200,0.85)";
  rrCtx(ctx, -14, 0, 28, 20, 8); ctx.fill();

  ctx.fillStyle = "rgba(30,30,30,0.55)";
  rrCtx(ctx, -18, -26, 36, 12, 6); ctx.fill();

  ctx.fillStyle = "rgba(0,0,0,0.20)";
  rrCtx(ctx, -10, -6, 20, 10, 5); ctx.fill();

  ctx.fillStyle = "rgba(255,255,255,0.95)";
  ctx.font = "900 12px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.strokeStyle = "rgba(0,0,0,0.55)";
  ctx.lineWidth = 4;
  const txt = o.ratio===1 ? "100" : "50";
  ctx.strokeText(txt, 0, -1);
  ctx.fillText(txt, 0, -1);

  ctx.restore();
}

// ===== ship render =====
function drawShip(ctx, xCenter, yCenter){
  const nowS = performance.now()/1000;

  const w = player.w;
  const h = player.h;

  const left = xCenter - w/2;
  const top  = yCenter - h/2;

  ctx.save();
  ctx.translate(left, top);

  ctx.fillStyle = "rgba(245,245,245,.98)";
  rrCtx(ctx, w*0.18, h*0.12, w*0.64, h*0.76, 20);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(w*0.50, 0);
  ctx.lineTo(w*0.74, h*0.18);
  ctx.lineTo(w*0.26, h*0.18);
  ctx.closePath();
  ctx.fillStyle = "rgba(255,60,60,.98)";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(w*0.50, h*0.38, w*0.14, 0, Math.PI*2);
  ctx.fillStyle = "rgba(120,210,255,.98)";
  ctx.fill();
  ctx.lineWidth = 3;
  ctx.strokeStyle = "rgba(0,0,0,.20)";
  ctx.stroke();

  ctx.fillStyle = "rgba(255,60,60,.95)";
  ctx.beginPath();
  ctx.moveTo(w*0.18, h*0.62);
  ctx.lineTo(0,      h*0.82);
  ctx.lineTo(w*0.20, h*0.82);
  ctx.closePath();
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(w*0.82, h*0.62);
  ctx.lineTo(w,      h*0.82);
  ctx.lineTo(w*0.80, h*0.82);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = "rgba(0,0,0,.35)";
  rrCtx(ctx, w*0.40, h*0.84, w*0.20, h*0.10, 8);
  ctx.fill();

  const baseFlame = 10 + 5*Math.abs(Math.sin(nowS*6));
  const boost = fireAnim > 0 ? 16 : 0;
  const flameH = baseFlame + boost;

  ctx.globalAlpha = 0.9;
  ctx.beginPath();
  ctx.moveTo(w*0.50, h*0.95);
  ctx.quadraticCurveTo(w*0.38, h*0.98 + flameH, w*0.50, h*1.10 + flameH);
  ctx.quadraticCurveTo(w*0.62, h*0.98 + flameH, w*0.50, h*0.95);
  ctx.closePath();
  ctx.fillStyle = "rgba(255,160,30,.95)";
  ctx.fill();

  ctx.globalAlpha = 0.75;
  ctx.beginPath();
  ctx.moveTo(w*0.50, h*0.96);
  ctx.quadraticCurveTo(w*0.43, h*0.98 + flameH*0.65, w*0.50, h*1.05 + flameH*0.65);
  ctx.quadraticCurveTo(w*0.57, h*0.98 + flameH*0.65, w*0.50, h*0.96);
  ctx.closePath();
  ctx.fillStyle = "rgba(255,230,120,.95)";
  ctx.fill();
  ctx.globalAlpha = 1;

  // HP bar
  const barPad = 4;
  const barW = w - barPad*2;
  const barH = 8;
  const barX = barPad;
  const barY = h + 10;

  ctx.fillStyle = "rgba(0,0,0,.55)";
  rrCtx(ctx, barX, barY, barW, barH, 4); ctx.fill();

  const hpRatio = clamp(hp / maxHp, 0, 1);
  let alpha = 1;
  if(hpRatio <= 0.30){
    alpha = 0.35 + 0.65 * Math.abs(Math.sin(nowS * 10));
  }
  ctx.globalAlpha = alpha;

  ctx.fillStyle = "rgba(255,60,60,.95)";
  const filledW = barW * hpRatio;
  ctx.fillRect(barX, barY, filledW, barH);

  ctx.globalAlpha = 1;
  ctx.restore();
}

// ===== loop =====
let last=performance.now();
function loop(now){
  const dt=Math.min(.033,(now-last)/1000); last=now;

  if(mode==="play"){
    stageClock += dt;
    timeS += dt;

    // ✅ 스테이지(15초)
    if(stageClock >= 15){
      stageClock -= 15;
      stage++;

      // ✅ 스테이지 배너 + 토스트 다시 뜨게
      stageFlash = 1.2;
      toast(`STAGE ${stage}`, 1.2);

      // ✅ 스테이지마다 포션 1개 제한 리셋
      potionSpawnedThisStage = false;

      // 스테이지 클리어 보너스 체력 회복
      const heal = Math.max(4, Math.floor(maxHp * 0.20 * healMul));
      hp = Math.min(maxHp, hp + heal);

      // (선택) 스테이지 효과음
      beep(660, 0.06, "triangle", 0.08);
    }

    // speed
    const accel = 4.0 + stage * 0.95;
    speed = Math.min(520, speed + dt * accel);

    // spawn
    const spawnInterval = Math.max(0.72, 1.2 - stage * 0.055);
    t += dt;
    if(t > spawnInterval){ spawnRow(); t=0; }

    // movement
    lane += (target-lane)*Math.min(1,dt*14);

    // objects move
    for(const o of objs) o.y += speed*dt;

    // timers
    fireCd=Math.max(0,fireCd-dt);
    fireAnim = Math.max(0, fireAnim - dt);
    toastT = Math.max(0, toastT - dt);
    stageFlash = Math.max(0, stageFlash - dt);

    // bullets
    for(const b of bullets) b.y -= b.v*dt;
    for(const b of bullets) b.t += dt;

    const px=laneX(lane)-player.w/2, py=player.y-player.h/2;

    // player collisions
    for(const o of objs){
      if(o.hit) continue;
      const ox=laneX(o.lane)-o.w/2, oy=o.y-o.h/2;
      if(aabb(px,py,player.w,player.h,ox,oy,o.w,o.h)){
        o.hit=true;
        if(o.type==="gate") applyGate(o);
        else if(o.type==="coin") collectCoin(o);
        else if(o.type==="potion") collectPotion(o);
        else hitEnemyBody(o);
      }
    }

    // bullet collisions (enemies)
    for(const b of bullets){
      if(b.y<-30) continue;
      for(const o of objs){
        if(o.type!=="enemy") continue;
        if(o.hp<=0) continue;
        if(o.lane!==b.lane) continue;
        const ox=laneX(o.lane)-o.w/2, oy=o.y-o.h/2;
        const bx=laneX(b.lane)-b.r, by=b.y-b.r;
        if(aabb(bx,by,b.r*2,b.r*2,ox,oy,o.w,o.h)){
          b.y=-9999;
          hitEnemyBullet(o,b.dmg);
          break;
        }
      }
    }

    // cleanup
    for(let i=objs.length-1;i>=0;i--){
      const o=objs[i];
      if(o.y>H+260) objs.splice(i,1);
      else if(o.hit) objs.splice(i,1);
      else if(o.type==="enemy" && o.hp<=0) objs.splice(i,1);
    }
    for(let i=bullets.length-1;i>=0;i--) if(bullets[i].y<-50) bullets.splice(i,1);

    // ✅ 자동공격 (play에서만)
    tryShoot();
  }

  draw();
  requestAnimationFrame(loop);
}

function draw(){
  // background
  const stageRatio = clamp(stageClock / 15, 0, 1);
  const nextWarn = stageClock > 10 ? (stageClock - 10) / 5 : 0;
  const hueA = (210 + stage * 18) % 360;
  const hueB = (210 + (stage + 1) * 18) % 360;
  let dh = ((hueB - hueA + 540) % 360) - 180;
  const hue = (hueA + dh * stageRatio + 360) % 360;
  const baseLight = 12 + Math.min(6, stage * 0.35);
  const warnPulse = nextWarn > 0 ? Math.sin(performance.now()/120) * 2 * nextWarn : 0;
  g.fillStyle = `hsl(${hue}, 40%, ${baseLight + warnPulse}%)`;
  g.fillRect(0,0,W,H);

  g.globalAlpha=.25; g.strokeStyle="#6aa6ff";
  for(let i=1;i<LANES;i++){ g.beginPath(); g.moveTo(W*i/LANES,0); g.lineTo(W*i/LANES,H); g.stroke(); }
  g.globalAlpha=1;

  // ===== START screen =====
  if(mode==="start"){
    g.fillStyle="rgba(0,0,0,0.45)";
    g.fillRect(0,0,W,H);

    g.fillStyle="rgba(255,255,255,0.96)";
    g.font="950 34px system-ui";
    g.textAlign="center";
    g.textBaseline="middle";
    g.fillText("SPACE RUN", W/2, 220);

    g.font="800 16px system-ui";
    g.fillStyle="rgba(255,255,255,0.85)";
    g.fillText("START를 눌러야 시작", W/2, 262);
    g.fillText("키보드: Space/Enter", W/2, 286);

    g.globalAlpha=1;
    g.fillStyle="rgba(0,0,0,0.60)";
    rr(START_BTN.x, START_BTN.y, START_BTN.w, START_BTN.h, 18); g.fill();
    g.strokeStyle="rgba(255,255,255,0.35)";
    g.lineWidth=2;
    rr(START_BTN.x, START_BTN.y, START_BTN.w, START_BTN.h, 18); g.stroke();

    g.fillStyle="rgba(255,255,255,0.96)";
    g.font="950 22px system-ui";
    g.fillText("START", W/2, START_BTN.y + START_BTN.h/2);

    g.textAlign="left";
    g.textBaseline="alphabetic";
    return;
  }

  // HUD
  g.fillStyle="rgba(255,255,255,.92)";
  if(mode === "play"){
    const drawOutlineText = (txt, x, y, font) => {
      g.font = font;
      g.lineJoin = "round";
      g.miterLimit = 2;
      g.lineWidth = 6;
      g.strokeStyle = "rgba(0,0,0,0.85)";
      g.fillStyle = "rgba(255,255,255,0.98)";
      g.strokeText(txt, x, y);
      g.fillText(txt, x, y);
    };
    const HUD_Y = 64;
    drawOutlineText(`점수: ${formatShort(troops)}`, 14, HUD_Y,      "950 28px system-ui");
    drawOutlineText(`코인: ${coins}`,               14, HUD_Y + 34, "950 24px system-ui");
  } else {
    g.font="900 20px system-ui";
    g.fillText(`점수: ${formatShort(troops)}`, 14, 30);
    const scorePowerHUD = calcScorePower();
    g.fillText(`공격력: ${up.dmg + scorePowerHUD}`, 14, 56);
    g.fillText(`목숨: ${lives} | 공격배율: x${dmgMul.toFixed(1)} | 회복배율: x${healMul.toFixed(1)}`, 14, 84);
    g.font="800 16px system-ui";
    g.fillText(`코인: ${coins}`, 14, 108);
  }

  g.font="800 13px system-ui";
  if(mode==="gameover") g.fillText("재시작: Space/클릭",14,132);
  else if(mode==="shop") g.fillText("상점: 클릭으로 구매  ·  닫기: B",14,132);

  // shop badge
  {
    g.save();
    const playing = (mode === "play");
    const bw = playing ? 92 : 102;
    const bh = playing ? 34 : 36;
    const bx = W - bw - 12;
    const by = 56;

    g.fillStyle = "rgba(0,0,0,0.60)";
    rr(bx, by, bw, bh, 12); g.fill();
    g.strokeStyle = "rgba(255,255,255,0.40)";
    g.lineWidth = 2;
    rr(bx, by, bw, bh, 12); g.stroke();
    g.fillStyle = "rgba(255,255,255,0.96)";
    g.font = playing ? "950 14px system-ui" : "950 15px system-ui";
    g.textAlign = "center";
    g.textBaseline = "middle";
    g.fillText("상점(B)", bx + bw/2, by + bh/2 + 0.5);
    g.restore();
  }

  // ✅ STAGE 배너 (스테이지 변경 알림)
  if(stageFlash > 0){
    const a = Math.min(1, stageFlash / 0.25);
    g.save();
    g.globalAlpha = 0.85 * a;
    g.fillStyle = "rgba(0,0,0,0.55)";
    rr(60, 170, W-120, 64, 18); g.fill();
    g.strokeStyle = "rgba(255,255,255,0.35)";
    g.lineWidth = 2;
    rr(60, 170, W-120, 64, 18); g.stroke();

    g.fillStyle = "rgba(255,255,255,0.96)";
    g.font = "950 26px system-ui";
    g.textAlign = "center";
    g.textBaseline = "middle";
    g.fillText(`STAGE ${stage}`, W/2, 202);

    g.restore();
    g.textAlign = "left";
    g.textBaseline = "alphabetic";
  }

  // objects
  for(const o of objs){
    const x=laneX(o.lane);
    if(o.type==="gate"){
      const col=o.k==="add"?"rgba(80,200,120,.85)":o.k==="mul"?"rgba(120,140,255,.85)":o.k==="sub"?"rgba(255,160,80,.9)":"rgba(200,90,255,.85)";
      g.fillStyle=col; rr(x-o.w/2,o.y-o.h/2,o.w,o.h,16); g.fill();
      g.fillStyle="rgba(0,0,0,.65)"; g.font="900 26px system-ui"; g.textAlign="center"; g.textBaseline="middle";
      const txt=o.k==="add"?`+${o.val}`:o.k==="mul"?`×${o.val}`:o.k==="sub"?`-${o.val}`:`÷${o.val}`;
      g.fillText(txt,x,o.y);
      g.textAlign="left"; g.textBaseline="alphabetic";
    } else if(o.type==="coin"){
      g.fillStyle="rgba(255,210,70,.95)";
      g.beginPath(); g.arc(x,o.y,22,0,Math.PI*2); g.fill();
      g.fillStyle="rgba(0,0,0,.65)"; g.font="900 14px system-ui"; g.textAlign="center"; g.textBaseline="middle";
      g.fillText(`+${o.amt}`,x,o.y);
      g.textAlign="left"; g.textBaseline="alphabetic";
    } else if(o.type==="potion"){
      drawPotion(g, x, o.y, o);
    } else {
      drawPlanet(g, x, o.y, o, timeS);
    }
  }

  // bullets
  for(const b of bullets){
    const x = laneX(b.lane);
    const y = b.y;
    const tt = (b.t || 0);
    const pulse = 0.6 + 0.4*Math.abs(Math.sin(tt*18));
    const len = 44;
    const w1  = 10;
    const w2  = 4;

    g.globalAlpha = 0.18 * pulse;
    g.strokeStyle = "rgba(120,210,255,1)";
    g.lineWidth = w1;
    g.lineCap = "round";
    g.beginPath(); g.moveTo(x, y); g.lineTo(x, y - len); g.stroke();

    g.globalAlpha = 0.35 * pulse;
    g.strokeStyle = "rgba(170,235,255,1)";
    g.lineWidth = w1 * 0.55;
    g.beginPath(); g.moveTo(x, y); g.lineTo(x, y - len); g.stroke();

    g.globalAlpha = 0.95;
    g.strokeStyle = "rgba(255,255,255,1)";
    g.lineWidth = w2;
    g.beginPath(); g.moveTo(x, y); g.lineTo(x, y - len); g.stroke();

    g.globalAlpha = 0.9;
    g.fillStyle = "rgba(255,255,255,1)";
    g.beginPath(); g.arc(x, y - len, 4, 0, Math.PI*2); g.fill();

    g.globalAlpha = 1;
  }

  // player
  const px = laneX(lane);
  drawShip(g, px, player.y);

  // mobile arrows
  if(mode === "play"){
    const y = BTN.y;
    BTN.left.y = y; BTN.right.y = y;

    g.globalAlpha = 0.9;
    g.fillStyle = "rgba(0,0,0,0.55)";
    rr(BTN.left.x,  y, BTN.size, BTN.size, 16); g.fill();
    rr(BTN.right.x, y, BTN.size, BTN.size, 16); g.fill();

    g.strokeStyle = "rgba(255,255,255,0.3)";
    g.lineWidth = 2;
    rr(BTN.left.x,  y, BTN.size, BTN.size, 16); g.stroke();
    rr(BTN.right.x, y, BTN.size, BTN.size, 16); g.stroke();

    g.fillStyle = "rgba(255,255,255,0.95)";
    g.beginPath();
    g.moveTo(BTN.left.x + BTN.size*0.62, y + BTN.size*0.25);
    g.lineTo(BTN.left.x + BTN.size*0.38, y + BTN.size*0.50);
    g.lineTo(BTN.left.x + BTN.size*0.62, y + BTN.size*0.75);
    g.closePath(); g.fill();

    g.beginPath();
    g.moveTo(BTN.right.x + BTN.size*0.38, y + BTN.size*0.25);
    g.lineTo(BTN.right.x + BTN.size*0.62, y + BTN.size*0.50);
    g.lineTo(BTN.right.x + BTN.size*0.38, y + BTN.size*0.75);
    g.closePath(); g.fill();

    g.globalAlpha = 1;
  }

  // toast
  if(toastT > 0){
    g.globalAlpha = 0.85;
    g.fillStyle = "rgba(0,0,0,0.45)";
    rr(20, 78, W-40, 30, 12); g.fill();
    g.fillStyle = "rgba(255,255,255,0.92)";
    g.font = "800 13px system-ui";
    g.textAlign = "center";
    g.textBaseline = "middle";
    g.fillText(toastMsg, W/2, 93);
    g.textAlign = "left";
    g.textBaseline = "alphabetic";
    g.globalAlpha = 1;
  }

  if(mode==="gameover"){
    g.fillStyle="rgba(0,0,0,.55)"; g.fillRect(0,0,W,H);
    g.fillStyle="rgba(255,255,255,.95)"; g.font="900 34px system-ui";
    g.textAlign="center"; g.textBaseline="middle";
    g.fillText("GAME OVER",W/2,H/2-24);
    g.font="800 18px system-ui";
    g.fillText("Space/클릭으로 재시작",W/2,H/2+36);
    g.textAlign="left"; g.textBaseline="alphabetic";
  }

  if(mode==="shop") drawShop();
}

function drawShop(){
  g.fillStyle="rgba(0,0,0,.62)"; g.fillRect(0,0,W,H);
  g.fillStyle="rgba(255,255,255,.95)"; g.font="950 28px system-ui";
  g.textAlign="center"; g.textBaseline="middle";
  g.fillText("상점 (클릭으로 구매)",W/2,90);

  g.globalAlpha=.9;
  g.fillStyle="rgba(255,255,255,.12)";
  rr(40,90,W-80,40,14); g.fill();
  g.fillStyle="rgba(255,255,255,.85)";
  g.font="900 14px system-ui";
  g.fillText("닫기(클릭) / B 키로 닫기",W/2,120);
  g.globalAlpha=1;

  g.textAlign="left"; g.textBaseline="alphabetic";
  g.font="900 18px system-ui"; g.fillStyle="rgba(255,255,255,.92)";
  g.fillText(`코인: ${coins}`, 40, 165);

  const items=shopItems();
  const x0=40,y0=220,w0=W-80,rowH=62;

  for(let i=0;i<items.length;i++){
    const it=items[i], y=y0+i*rowH;
    g.globalAlpha=.95;
    g.fillStyle="rgba(255,255,255,.10)"; rr(x0,y,w0,rowH-10,16); g.fill();
    g.fillStyle="rgba(255,255,255,.92)"; g.font="800 16px system-ui";
    g.fillText(it.name,x0+16,y+24);

    const canBuy = coins >= it.cost;
    g.fillStyle = canBuy ? "rgba(80,200,120,.95)" : "rgba(255,120,120,.95)";
    g.font="900 16px system-ui"; g.textAlign="right";
    g.fillText(`${it.cost} 코인`,x0+w0-16,y+24);
    g.textAlign="left";
  }
  g.globalAlpha=1;
}

// ===== start =====
resetRun();
requestAnimationFrame(loop);
</script>
</body>
</html>
